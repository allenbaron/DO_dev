---
title: "Analysis of Zika virus-related disease name & synonyms"
date: "2025-05-23"
output:
    html_notebook:
        toc: true
        toc_float: true
        code_folding: hide
---

The goal of this analysis is to determine what name is in primary use at this stage for DOID:0060478 (currently 'Zika fever') and DOID:0080180 (currently 'Zika virus congenital syndrome').

_Note that this is not a genetic disease, so OMIM cannot be relied on for identifying the primary name. Other sources, such as Orphanet, often have names that are unique to those resources but are not used by the clinical or research communities and cannot, therefore, be relied on._


```{r setup, include=FALSE}
library(europepmc)
library(tidyverse)
library(xml2)
library(here)
library(hues)
library(plotly)
```

```{r in_progress_data}
data_dir <- here::here("data/disease_info")
data_file <- file.path(data_dir, "Zika.rda")

if (!dir.exists(data_dir)) dir.create(data_dir, recursive = TRUE)
```

```{r custom_functions}
# get_ftxt_safely() will automatically get PMC articles or books and will NOT
#   fail if on errors caused by individual download failures
safe_epmc_ftxt <- purrr::safely(europepmc::epmc_ftxt, otherwise = NA, quiet = FALSE)
safe_epmc_ftxt_bk <- purrr::safely(europepmc::epmc_ftxt_book, otherwise = NA, quiet = FALSE)

get_ftxt_safely <- function(pmcid = NA, bookid = NA) {
    if (is.na(pmcid) && is.na(bookid) ) return(NA)
    if (!is.na(pmcid)) {
        out <- list(safe_epmc_ftxt(pmcid))
    } else {
        out <- list(safe_epmc_ftxt_bk(bookid))
    }
    cat(".")
    out
}


# parse_ftxt_xml() parses results from get_ftxt_safely()
parse_ftxt_xml <- function(safe_ftxt_xml, xml_accessor) {
    if (!is.null(safe_ftxt_xml$error)) {
        return(paste0("ERROR: ", safe_ftxt_xml$error$message))
    }
    out <- safe_ftxt_xml$result |>
        xml2::xml_find_all(xml_accessor) |>
        xml2::xml_text()

    if (length(out) == 0) {
        out <- paste0(
            "ERROR [NO BODY]: ",
            xml2::xml_text(safe_ftxt_xml$result)
        )
        if (length(out) == 0) {
            out <- "ERROR: No text extractable"
        }
    } else if (length(out) > 1) {
        out <- DO.utils::vctr_to_string(out, delim = "%%%%%") |>
            paste0("WARNING: Multilength output, separated by %%%%%.")
    }

    out
}
```


These are the terms currently in DO, or that have been identified in initial searches.

```{r}
terms <- c(
    'Zika fever', # current label, DOID:0060478
    'Zika virus disease', # existing synonnym
    'Zika virus congenital syndrome', # current label, DOID:0080180
    'ZIKV congenital infection', # existing synonym
    "congenital Zika syndrome",
    "Zika"
)
```


Begin by searching EuropePMC for articles that contain one or more exact matches to these terms using the default search. Full articles will be important here because most titles will be capitalized. _Save output to file, to avoid potential of repeat API call._

```{r}
search_str <- 'OPEN_ACCESS:y AND "Zika"'

if (!file.exists(data_file)) {
    res <- europepmc::epmc_search(search_str, synonym = FALSE, limit = 40000)

    save(res, file = data_file)
} else {
    load(data_file)
}
```

The number of publication hits (`r format(nrow(res), big.mark = ",")`) is more than can reasonably be processed using all the full text articles. A sample (<= 5,000) will be used taking a similar fraction of articles from each year and excluding preprints and retractions, as well as, any publications lacking a PMC or book ID (these will not be accessible).

```{r}
frac <- round(5000 / nrow(res), 2)

res_tidy <- res |>
    dplyr::filter(
        !stringr::str_detect(pubType, "retract|preprint"),
        !(is.na(pmcid) & is.na(bookid))
    ) |>
    dplyr::select(
        "id", "title", "pubYear", pubDate = "firstPublicationDate",
        "pmcid", "bookid") |>
    dplyr::mutate(
        pubDate = lubridate::as_date(pubDate),
        pubYear = lubridate::year(pubDate)
    )

if (!exists("res_sample")) {
    res_sample <- res_tidy |>
        dplyr::slice_sample(prop = frac, by = pubYear)

    save(res, res_sample, file = data_file)
}

if (!exists("res_ftxt")) {
    res_ftxt <- res_sample |>
        dplyr::rowwise() |>
        dplyr::mutate(ft_xml = get_ftxt_safely(pmcid, bookid)) |>
        dplyr::mutate(ft = parse_ftxt_xml(ft_xml, "//body"))
    
    save(res, res_sample, res_ftxt, file = data_file)
}
```


# Evaluating Usage

Extracting all these values from the full text of the sample publications and all the titles (in a case-insensitive manner).
```{r}
regex_str <- terms |>
    DO.utils::length_sort(decreasing = TRUE) |>
    paste0(collapse = "|")

term_df <- res_tidy |>
    dplyr::left_join(
        res_ftxt,
        by = c("id", "title", "pubYear", "pubDate", "pmcid", "bookid")
    ) |>
    dplyr::select("id", "pubDate", "title", "ft") |>
    dplyr::mutate(
        title_match = stringr::str_extract_all(
            .data$title,
            stringr::regex(regex_str, ignore_case = TRUE)
        ),
        ft_match = stringr::str_extract_all(
            .data$ft,
            stringr::regex(regex_str, ignore_case = TRUE)
        )
    ) |>
    tidyr::unnest(title_match, keep_empty = TRUE) |>
    tidyr::unnest(ft_match, keep_empty = TRUE) |>
    dplyr::mutate(ft = !is.na(ft)) |>
    tidyr::pivot_longer(
        title_match:ft_match,
        names_to = c("source", ".value"),
        names_sep = "_",
        values_drop_na = FALSE
    ) |>
    # drop full text lines where no text was available
    dplyr::filter(.data$source == "title" | .data$ft)
```

The number of publications with and without matches in their titles or full text, noting whether their full-text was obtained are as follows:

```{r}
term_df |>
    DO.utils::collapse_col(c("source", "match")) |>
    dplyr::mutate(match = !is.na(match)) |>
    dplyr::count(ft, match) |>
    dplyr::mutate(pct = round(n / sum(n) * 100, 2)) |>
    dplyr::rename(ft_obtained = "ft")
```

Any non-matches will just be dropped for the analysis of names, and special quote or dash marks will be standardized.

```{r}
matches <- term_df |>
    dplyr::filter(!is.na(.data$match)) |>
    dplyr::mutate(
        match = stringr::str_replace_all(
            .data$match,
            c("['‘’′]" = "'", "[-‐–]" = "-")
        ),
        match_lc = stringr::str_to_lower(.data$match)
    ) |>
    dplyr::select(-"title")
```

The number of case-insenitive matches in the titles and full text are as follows:
```{r}
matches |>
    DO.utils::collapse_col("match") |>
    dplyr::count(.data$source, .data$match_lc) |>
    dplyr::mutate(
        pct = round(n / sum(n) * 100, 2),
        .by = "source"
    ) |>
    dplyr::arrange(.data$source, -.data$pct)
```

The number of matches, in the full text only, preserving case are as follows:
```{r}
ft_matches <- matches |>
    dplyr::filter(.data$source == "ft")

ft_matches |>
    DO.utils::collapse_col("match_lc") |> 
    dplyr::count(.data$match, sort = TRUE)
```

The preferred capitalization of these terms is already obvious, with Zika being commonly used in title case and all other words being lowercase, so the comparison will be simplified again to case-insensitive matches.

Again limited to those with full-text but also including their titles:
```{r}
matches |>
    dplyr::filter(.data$ft) |>
    DO.utils::collapse_col(c("source", "match_lc")) |> 
    dplyr::count(.data$match_lc, sort = TRUE) |>
    dplyr::mutate(pct = round(n / sum(n) * 100, 2))
```


```{r}
matches |>
    DO.utils::collapse_col(c("source", "match_lc")) |> 
    dplyr::count(.data$match_lc, sort = TRUE)
```


It will be easier to discern name usage better if all uses are included, they are split by disease type, and "Zika" occcurrences are ignored (since they don't provide information about the disease names). Also, 

First, looking 

```{r}
matches |>
    dplyr::filter(
        stringr::str_detect(
            .data$match_lc,
            stringr::coll("congenital", ignore_case = TRUE)
        )
    ) |>
    DO.utils::collapse_col(c("source", "match_lc")O |> 
    dplyr::count(.data$match_lc, sort = TRUE)
```

The current name in DO for **DOID:0080180** is used but in dead last and significantly less than it's synonym 'congenital Zika syndrome'. **These should be swapped.**

```{r}
ft_matches |>
    dplyr::filter(
        !stringr::str_detect(
            .data$match_lc,
            stringr::coll("congenital", ignore_case = TRUE)
        ),
        !.data$match_lc == "zika"
    ) |>
    DO.utils::collapse_col("match_lc") |> 
    dplyr::count(.data$match_lc, sort = TRUE)
```

The preference for **DOID:0060478** is much less clear, with the two terms being used almost equally. It's possible that Zika virus disease could be used in reference to either Zika fever or congenital Zika syndrome. In the Disease Ontology, DOID:0060478 has Zika virus disease as an exact synonym but if that is truly an exact synonym, then DOID:0080180 should be a child of this term.

Organized by publication date and binned into year intervals (after dropping Zika), the results are as follows:

```{r}
g_colors <- hues::iwanthue(dplyr::n_distinct(ft_matches$match_lc) - 1)

ft_matches |>
    dplyr::filter(.data$match_lc != "zika") |>
    DO.utils::collapse_col("match_lc") |>
    dplyr::mutate(n = length(.data$source), .by = "match_lc") |>
    ggplot2::ggplot() +
    ggplot2::geom_freqpoly(
        ggplot2::aes(x = pubDate, color = match_lc),
        binwidth = 365
    ) +
    ggplot2::scale_color_manual(values = g_colors) +
    ggplot2::facet_wrap(~ source, ncol = 1, scales = "free_y")
```
Hmmm.. that doesn't clarify the use of Zika fever versus Zika virus disease at all. Issue [#1489](https://github.com/DiseaseOntology/HumanDiseaseOntology/issues/1489) has been opened to discuss this further.


