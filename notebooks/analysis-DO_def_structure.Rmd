---
title: "Evaluation of Definition Structure"
author: "J. Allen Baron"
date: "Created: 2022-04-06<br style='line-height: 2;'>Updated: 2024-09-16"
output: 
    html_notebook:
        toc: true
        toc_float:
            collapsed: false
        df_print: paged
        code_folding: hide
---

# Purpose

To better understand the style of definitions used within the Human Disease Ontology, particularly with regard to "characterized by" statements.


# Background

The definition [style guide](https://docs.google.com/document/d/1YUv_7noj3JJIuSSECU3ufAbXvDiPTugIDv7Dm0mRypw) indicates that definitions should always begin with their parent term and a description of the disease's etiology (cause).

Lynn has explained that definitions frequently use "characterized by", but it's not clear to me if this should preface the etiology or signs/symptoms, and "has_material_basis_in", which as I understand it is only used when a genetic cause is identified.

```{r setup, include = FALSE}
library(tidyverse)
library(DO.utils)
library(tidytext)
library(wordcloud2)
library(kableExtra)

# avoid summarize messages about grouping
options(dplyr.summarise.inform = FALSE)

# custom functions
percent <- function(x) {
    round(x / sum(x) * 100, 2)
}

add_percent <- function(.df, .col, .group = NULL) {
    .g <- deparse(substitute(.group))
    if (.g != "NULL") {
        .df <- dplyr::group_by(.df, {{ .group }})
    }
    df_out <- dplyr::mutate(.df, pct = percent({{ .col }}))
    if (.g != "NULL") {
        df_out <- dplyr::ungroup(df_out)
    }
    df_out
}

length_order <- function(data, cols, ...) {
    .cols <- tidyselect::eval_select(rlang::enquo(cols), data)
    if (length(.cols) > 1) {
        index <- do.call(
            "order",
            c(
                purrr::map(
                    dplyr::select(data, dplyr::all_of(.cols)),
                    stringr::str_length
                ),
                ...
            )
        )
    } else {
        index <- order(stringr::str_length(dplyr::pull(data, .cols)), ...)
    }
    data[index, ]
}
```

```{r data}
repo <- DOrepo("~/Documents/Ontologies/HumanDiseaseOntology")
q <- "
    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    PREFIX owl: <http://www.w3.org/2002/07/owl#>
    PREFIX oio: <http://www.geneontology.org/formats/oboInOwl#>
    PREFIX IAO: <http://purl.obolibrary.org/obo/IAO_>

    SELECT ?id ?label ?obs ?def ?parent_label
    WHERE {
        ?c IAO:0000115 ?def ;
            oio:id ?id ;
            rdfs:label ?label;
            rdfs:subClassOf ?parent .
        ?parent rdfs:label ?parent_label .
        FILTER(CONTAINS(STR(?c), 'DOID'))
        FILTER(!ISBLANK(?parent))
        OPTIONAL { ?c owl:deprecated ?obs . }
    }"

def <- repo$doid$query(q) %>%
    tibble::as_tibble() %>%
    tidyr::unnest(obs, keep_empty = TRUE) %>%
    dplyr::mutate(
        obs = dplyr::if_else(is.na(obs), FALSE, as.logical(obs)),
        cb_format = stringr::str_extract(def, "(that is )?characterized by"),
        chr_by = stringr::str_extract(def, "characterized by.*") %>%
            stringr::str_squish()
    ) %>%
    dplyr::arrange(id)
```


# Questions and Analysis

## "characterized by"

1. How many definitions use "characterized by" and do the majority use the format "that is characterized by" or just "characterized by"?

```{r}
dplyr::count(def, obs, cb_format) %>%
    add_percent(n)
```
The "characterized by" statement appears in about 1/2 of the non-obsolete definitions, with both formats used equally.


2. Is there a difference in format based on when a term was created? _Newer terms can be identified by a leading "0"._

```{r}
def <- def %>%
    dplyr::mutate(newer = stringr::str_detect(id, "DOID:0"))

def %>%
    dplyr::filter(!obs) %>%
    dplyr::count(newer, cb_format) %>%
    add_percent(n)
```
Newer IDs more often use "characterized by" without the "that is".

**PREFER format without "that is ".**

**NOTE 2024-09-16, JAB:** Lynn has said she prefers to include 'that is' before 'characterized by' but I still don't use it for brevity's sake and sticking with the more common pattern.


3. What is the "characterized by" statement for?

```{r}
def %>%
    dplyr::filter(!is.na(chr_by)) %>%
    dplyr::select(chr_by)
```

There is a mix of its use preceding a list of symptoms/phenotypes/signs and use preceding a cause. I'll need to ask for clarification on the preference.

**The consensus is that "characterized by" should precede a list of symptoms/phenotypes/signs.**


4. Where does "characterized by" usually occur in a definition?
Or, in other words, how many words precede "characterized by"?
    
```{r}
def %>%
    dplyr::mutate(
        before_cb = stringr::str_extract(
            def,
            ".*?characterized by"
        ) %>%
            stringr::str_remove("(that is )characterized by")
    ) %>%
    dplyr::select(id, before_cb) %>%
    dplyr::filter(!is.na(before_cb)) %>%
    tidytext::unnest_tokens(
        output = "word",
        input = before_cb,
        token = "words"
    ) %>%
    dplyr::count(id, name = "n_words") %>%
    dplyr::count(n_words, name = "occurrences") %>%
    ggplot() +
    geom_col(aes(x = n_words, y = occurrences))
```

Most often the "characterized by" is the fourth or fifth word which means it's generally at the beginning of a definition, probably right after the "A {parent}" statement.

**"characterized by" should generally be at the start of a definition.**


### Syndromes (and "characterized by")

1. What about "characterized by" statements for syndromes?

```{r}
syndrome_q <- "
    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
    PREFIX owl: <http://www.w3.org/2002/07/owl#>
    PREFIX oio: <http://www.geneontology.org/formats/oboInOwl#>
    PREFIX IAO: <http://purl.obolibrary.org/obo/IAO_>
    PREFIX DOID: <http://purl.obolibrary.org/obo/DOID_>

    SELECT ?id ?label ?obs ?def
    WHERE {
        ?c IAO:0000115 ?def ;
            oio:id ?id ;
            rdfs:label ?label ;
            rdfs:subClassOf DOID:225 .
        OPTIONAL { ?c owl:deprecated ?obs . }
    }"

syn_def <- repo$doid$query(syndrome_q) %>%
    tibble::as_tibble() %>%
    tidyr::unnest(obs, keep_empty = TRUE) %>%
    dplyr::mutate(
        obs = dplyr::if_else(is.na(obs), FALSE, as.logical(obs)),
        cb_format = stringr::str_extract(def, "(that is )?characterized by"),
        chr_by = stringr::str_extract(def, "characterized by.*") %>%
            stringr::str_squish()
    ) %>%
    dplyr::arrange(id)
```


```{r}
count(syn_def, obs, cb_format)
```

"characterized by" is _VERY_ common for syndromes.


2. What about syndromes in name ONLY for which causes are known? _(i.e. those not in the syndrome branch of DO but with "syndrome" in their name)_

```{r}
def <- def %>%
    dplyr::mutate(
        syndrome_in_name = stringr::str_detect(label, "[Ss]yndrome"),
        true_syndrome = id %in% syn_def$id
    )

def %>%
    dplyr::filter(!obs) %>%
    dplyr::count(syndrome_in_name, true_syndrome) %>%
    add_percent(n)
```

About 10% of disease are syndromes in name only, which is about twice as many as the true syndromes.


```{r}
sino <- def %>%
    dplyr::filter(syndrome_in_name, !true_syndrome, !obs)

sino %>%
    dplyr::count(cb_format) %>%
    add_percent(n)
```

Most still have "characterized by" in their definitions.

```{r}
sino %>%
    dplyr::select(def)
```

It seems like "Budd-Chiari syndrome" (DOID:11512) really is a syndrome (no known cause). Maybe some of these should also be classified as syndromes? 


3. How many syndromes _in name only_ have causes identified?

```{r}
sino_cause <- sino %>%
    dplyr::filter(stringr::str_detect(def, "from"))

sino_cause
```

About `r nrow(sino_cause)`.

**Generally syndromes start with a "characterized by" list, which may be followed by the cause if known.**


## NOT "characterized by"

1. When would a "characterized by" statement be **_inappropriate_**?

```{r}
no_cb <- def %>%
    dplyr::filter(is.na(chr_by)) %>%
    dplyr::select(def)
no_cb
```

Allergies, autoimmune diseases, and infectious diseases do not appear to use "characterized by" statements.

2. When "characterized by" is absent, what follows the "parent" statement?

```{r}
no_cb <- def %>%
    dplyr::filter(is.na(chr_by)) %>%
    dplyr::mutate(
        after_parent = purrr::map2_chr(
            .x = def,
            .y = parent_label,
            ~ stringr::str_extract(.x, paste0(.y, ".*")) %>%
                stringr::str_remove(.y) %>%
                stringr::str_squish()
        )
    ) %>%
    dplyr::select(id, after_parent) %>%
    dplyr::filter(!is.na(after_parent))

no_cb_word <- no_cb %>%
    tidytext::unnest_tokens(
        output = "word",
        input = after_parent,
        token = "words"
    ) %>%
    dplyr::group_by(id) %>%
    dplyr::mutate(pos = dplyr::row_number()) %>%
    dplyr::ungroup() %>%
    dplyr::count(pos, word) %>%
    dplyr::arrange(pos, dplyr::desc(n)) %>%
    dplyr::group_by(pos) %>%
    dplyr::mutate(rank = dplyr::row_number(rev(n))) %>%
    dplyr::ungroup() %>%
    dplyr::filter(rank <= 10, pos < 4) %>%
    add_percent(n, pos)

no_cb_word %>%
    dplyr::filter(rank < 6) %>%
    dplyr::select(pos, word, pct) %>%
    tidyr::pivot_wider(
        names_from = pos,
        values_from = pct
    )
```

It seems that aside from "characterized by" the other major statements are primarily attached with "that" and include: "has_material_basis_in" > "located_in" > "involves" > "results_in" > "derives_from".

The patterns may be easier to view as 3-grams (the first 3 words as a set) where those with relationship terms (identifiable by the presence of an underscore) have all following words removed in order to collapse them together. I think it would also be worth including "characterized by" to find out where it fits in terms of use frequency.

```{r}
def %>%
    dplyr::mutate(
        after_parent = purrr::map2_chr(
            .x = def,
            .y = parent_label,
            ~ stringr::str_extract(.x, paste0(.y, ".*")) %>%
                stringr::str_remove(.y) %>%
                stringr::str_squish()
        )
    ) %>%
    dplyr::select(id, after_parent) %>%
    dplyr::filter(!is.na(after_parent)) %>%
    dplyr::mutate(
        after_parent = stringr::str_replace_all(
            after_parent,
            c(
                "located in" = "located_in",
                "results in" = "results_in",
                "(that is ?)characterized[ _]+by" = "characterized_by",
                "characterized by" = "characterized_by"
            )
        )
    ) %>%
    tidytext::unnest_ngrams(output = "three", input = after_parent, n = 3) %>%
    dplyr::mutate(
        three = stringr::str_replace(
            three,
            "(.*_[a-z]+).*",
            "\\1"
        )
    ) %>%
    dplyr::group_by(id) %>%
    dplyr::filter(dplyr::row_number() == 1) %>%
    dplyr::ungroup() %>%
    dplyr::count(three, sort = TRUE) %>%
    add_percent(n)
```
Ultimately it seems like the most frequent statements (ranked) are as follows:

**characterized by >> has_material_basis_in >> located_in > results_in > derives_from > is a > has_allergic_trigger**

Some less frequently used statements use: involves > arises from > affects > composed of


3. What is included in the "is a" statement?

```{r}
no_cb %>%
    dplyr::mutate(
        is_a = stringr::str_extract(after_parent, "that is a ([^ ]+ ){2}") %>%
            stringr::str_remove("that is a ")
    ) %>%
    dplyr::filter(!is.na(is_a)) %>%
    dplyr::count(is_a, sort = TRUE)
```

It appears that it is primarily used in place of one of the more common statements.

**"that is a" should be avoided and used in only rare instances.**


## "caused by"

1. How are "caused by" statements used?

```{r}
def <- def %>%
    dplyr::mutate(
        caused = stringr::str_extract(def, "caused by.*") %>%
            stringr::str_squish(),
        has_caused = !is.na(caused)
    )

count(def, obs, has_caused) %>%
    add_percent(n)

count(def, newer, has_caused) %>%
    add_percent(n)
```

These statements are not common. They're use has declined in non-obsolete, newer terms.

**NOTE 2022-04-04, JAB:** Lynn stated "caused by" should generally be avoided.


## Parentheses & Terminology

1. Should definitions include words in parentheses?

```{r}
def <- def %>%
    dplyr::mutate(
        has_paren = stringr::str_detect(def, "\\(\\w+"),
        paren_content = stringr::str_extract_all(def, "\\(.+?\\)") %>%
            purrr::map_chr(DO.utils::collapse_to_string)
    )

dplyr::count(def, has_paren) %>%
    add_percent(n)
```

Most often they **do not** include parentheses but they do exist.


2. Are medical terms or their explanations included in parentheses?

Looking at content...

```{r}
dplyr::filter(def, has_paren) %>%
    dplyr::select(paren_content)
```

The first few are scientific genus species names and I know there are gene names. Quantifying those...

```{r}
dplyr::filter(def, has_paren) %>%
    dplyr::mutate(
        is_species = stringr::str_detect(def, "\\([A-Z][a-z]+ [a-z]+"),
        is_gene = stringr::str_detect(def, "\\([A-Z0-9]{3,}")
    ) %>%
    dplyr::summarize(
        species = sum(is_species),
        gene = sum(is_gene),
        other = sum(!is_gene & !is_species)
    )
```

Reviewing content that are not genes or species names...

```{r}
def %>%
    dplyr::mutate(
        is_species = stringr::str_detect(def, "\\([A-Z][a-z]+ [a-z]+"),
        is_gene = stringr::str_detect(def, "\\([A-Z0-9]{3,}")
    ) %>%
    dplyr::filter(has_paren, !is_species, !is_gene) %>%
    dplyr::select(paren_content)
```

There **are** medical terms or their explanations in parentheses. There's not a neat regular expression pattern to identify and quantify them, but the number relative to the total number of definitions is proportionally low suggesting a preference **not** to use them. But again, I'll need to ask for clarification as all versions exist.

**The preference should be use of medical terms over layman's terms but it is not a hard and fast rule.**


## Common N-grams

The goal here is to identify common usage among definitions irrespective of order to try identify all words/2-grams/3-grams that serve to delineate statements.


1. What are the top 20 words (excluding stop words)?

```{r}
word <- def %>%
    dplyr::select(id, def) %>%
    tidytext::unnest_tokens(
        output = "word",
        input = "def",
        token = "words"
    ) %>%
    dplyr::anti_join(tidytext::stop_words, by = "word")

word_count <- word %>%
    dplyr::count(word, name = "freq", sort = TRUE) %>%
    add_percent(freq)

word_count %>%
    dplyr::filter(dplyr::row_number() <= 20)
```

Visualizing more results as a word cloud...

```{r}
word_count %>%
    dplyr::mutate(
        word = stringr::str_replace(
            word,
            "has_material_basis_in",
            "has_mat_basis"
        )
    ) %>%
    wordcloud2::wordcloud2(size = 0.5, fontWeight = "normal")
```


2. What are the top 2-grams?

```{r}
g2 <- def %>%
    dplyr::select(id, def) %>%
    tidytext::unnest_ngrams(
        output = "ngram",
        input = "def",
        n = 2
    )

g2 <- g2 %>%
    dplyr::count(ngram, name = "freq", sort = TRUE) %>%
    add_percent(freq)

g2 %>%
    dplyr::filter(dplyr::row_number() <= 20)
```

2. What are the top 3-grams?

```{r}
g3 <- def %>%
    dplyr::select(id, def) %>%
    tidytext::unnest_ngrams(
        output = "ngram",
        input = "def",
        n = 3
    )

g3 <- g3 %>%
    dplyr::count(ngram, name = "freq", sort = TRUE) %>%
    add_percent(freq)

g3 %>%
    dplyr::filter(dplyr::row_number() <= 20)
```

That apparently is not a very useful exercise.


## Genetic Information

```{r include = FALSE}
# simple-ish function for lengthening a column by splitting
inflate_col_ <- function(df, col, sep = " | ", fixed = TRUE,
                         values_drop_na = TRUE) {
    col_nm <- rlang::as_string(rlang::ensym(col))
    n_max <- max(
        stringr::str_count(df[[col_nm]], stringr::coll(sep)),
        na.rm = TRUE
    ) + 1
    
    sep_esc <- if (fixed) paste0("\\Q", sep, "\\E") else sep
    
    df_wider <- tidyr::separate(
        df,
        {{ col }},
        into = paste0("..inflate", 1:n_max),
        sep = sep_esc,
        fill = "right"
    )
    df_inflated <- tidyr::pivot_longer(
        df_wider,
        cols = tidyselect::starts_with("..inflate"),
        names_to = "..inflate_delete",
        values_to = col_nm,
        values_drop_na = values_drop_na
    ) %>%
        dplyr::select(-..inflate_delete)
    df_inflated
}
```

Not all "has_material_basis_in" used in definitions refer to a genetic basis and no one term or pattern exists to identify all of these. Most, if not all, can be matched with a search for words like mutation, gene, chromosome, etc. The breakdown of matches used to identify genetic "has_material_basis_in" definitions is as follows (with some definitions having multiple matches):


```{r}
tmp <- def %>%
    dplyr::select(id:def) %>%
    dplyr::mutate(
        genetic_basis = stringr::str_extract_all(
            def,
            "(mut|vari)ation|chromosom|inherit| gene |[0-9]+[pq][0-9]+"
        ) %>%
            purrr::map_chr(
                ~ stringr::str_replace_all(.x, "[0-9]+[pq][0-9]+", "chrom_loc") %>%
                    unique() %>%
                    sort() %>%
                    DO.utils::vctr_to_string(delim = " | ")
            )
    ) %>%
    dplyr::filter(
        stringr::str_detect(def, "material[ _]basis[ _]"),
        genetic_basis != ""
    )

tmp %>%
    dplyr::count(genetic_basis) %>%
    inflate_col_(genetic_basis) %>%
    dplyr::count(genetic_basis, wt = n, sort = TRUE)
```

Combined, those patterns identify `r format(dplyr::n_distinct(tmp$id), big.mark = ",")` (of `r format(dplyr::n_distinct(def$id), big.mark = ",")`) definitions with genetic bases (~ `r round(dplyr::n_distinct(tmp$id) / dplyr::n_distinct(def$id) * 100, 1)`%).

The most common patterns are as follows:

```{r}
hmbi <- tmp %>%
    dplyr::mutate(
        hmbi = stringr::str_remove(def, ".*basis[ _]in[ _]+"),
        # replace gene symbols with placeholder
        hmbi = stringr::str_replace_all(
            hmbi,
            c(" [A-Z0-9\\-]{3,}([ .,])" = " GENE_SYM\\1",
              " [X0-9]+[pq][0-9.]*([ .,])" = " CHROM_SYM\\1")
        )
    )
```


```{r}
words <- hmbi %>%
    dplyr::select(label, hmbi) %>%
    tidytext::unnest_tokens(hmbi, output = "words") %>%
    dplyr::group_by(label) %>%
    dplyr::mutate(pos = dplyr::row_number()) %>%
    dplyr::ungroup()

words %>%
    dplyr::group_by(pos, words) %>%
    dplyr::summarize(n = length(words)) %>%
    dplyr::mutate(
        rank = dplyr::row_number(dplyr::desc(n)),
        words = paste0(words, " (", n, ")")
    ) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(pos, rank) %>%
    dplyr::select(-n) %>%
    tidyr::pivot_wider(id_cols = rank, names_from = pos, values_from = words)
```


```{r}
g3 <- hmbi %>%
    dplyr::select(label, hmbi) %>%
    tidytext::unnest_ngrams(hmbi, n = 3, output = "words", to_lower = FALSE) %>%
    dplyr::group_by(label) %>%
    dplyr::mutate(pos = dplyr::row_number()) %>%
    dplyr::ungroup()

dplyr::count(g3, words, sort = TRUE)
```

The major pattern BY FAR is probably "has_material_basis_in mutation in the {GENE SYMBOL} gene on chromosome {CYTOGENETIC LOCATION}." It's challenging to know how often gene names are included but it might be possible to measure how often the gene symbol appears without the gene name.

```{r}
hmbi %>%
    dplyr::mutate(
        gene_phrase = stringr::str_extract(
            hmbi,
            "([A-Za-z0-9._\\-,]+ ){0,3}genes?( [A-Za-z0-9._\\-,]+){0,3}"
        )
    ) %>%
    dplyr::count(gene_phrase, sort = TRUE) %>%
    dplyr::mutate(pct = round(n / sum(n) * 100, 2))
```
```{r}
gene_id <- hmbi %>%
    dplyr::mutate(
        gene_id = stringr::str_extract(hmbi,"the.*gene|gene for .*")
    ) %>%
    dplyr::count(gene_id, sort = TRUE) %>%
    dplyr::mutate(pct = round(n / sum(n) * 100, 2))

gene_id
```

It seems ~ `r sum(gene_id$pct[c(1, 4:9)])` of all genetic has_material_basis_in statements have only the gene symbol (and not any type of name). This identifies a common, but not exclusive, pattern.


### Inheritance

Sometimes diseases caused by the same gene are differentiated by OMIM based on inheritance (and possibly phenotype). Generally, OMIM uses "heterozygous" vs "homozygous" in definitions to describe variants and that basically corresponds to dominant vs recessive inheritance but they aren't the same. Prompted by these concerns, an exploration of inheritance terminology in definitions follows.

**Question: How is inheritance described in definitions?**

NOTE: Deprecated terms are excluded from analysis.

First, we'll need to identify which inheritance terms/phrases exist.

```{r}
def_inherit <- def %>%
    dplyr::select(id:parent_label) %>%
    dplyr::filter(!obs) %>%
    dplyr::mutate(
        term = stringr::str_extract_all(
            def,
            DO.utils::collapse_to_string(
                "(",
                "autosom[^ ]*( [^ [:punct:]]*)|",
                "[^ ]*link[^ ]*|",
                "[^ ]*genic[^ [:punct:]]*|", # many "genic" words --> limit
                "de novo",
                ")+", # keep adjacent matching terms together
                delim = ""
            )
        ),
        term = purrr::map_chr(
            term,
            ~ stringr::str_trim(.x) %>%
                DO.utils::collapse_to_string(unique = TRUE, na.rm = TRUE)
        )
    ) %>%
    dplyr::filter(!is.na(term))

dplyr::count(def_inherit, term) %>%
    dplyr::arrange(term)
```

1. It looks like it's common to have a combination of 5 words together related to autosomal inheritance in various arrangement: autosomal, recessive, dominant, inheritance, and gene plus derivatives.
    - I wonder what the more complete 'autosomal gene(s|tic)' phrases are?
2. Need to limit the 'link' search to include just '[XY]-' before (or nothing) and only the word boundary/-ed/-age after.
3. Need to limit the 'genic' search to just the mono-/di-/poly-/inter- set.

Refining that search a bit based on those observations, returns:

```{r}
def_inherit <- def %>%
    dplyr::select(id:parent_label) %>%
    dplyr::filter(!obs) %>%
    dplyr::mutate(
        term = stringr::str_extract_all(
            def,
            DO.utils::collapse_to_string(
                "(",
                "(\\b(autosom|recess|domi|gene|inher)[a-z]*\\b ?)+|",
                "[XY].?link(ed|age)?\\b|",
                "(inter|mono|di|poly)genic\\b|", # many "genic" words --> limit
                "de novo\\b",
                ")+", # keep adjacent matching terms together
                delim = ""
            )
        ),
        term = purrr::map_chr(
            term,
            ~ stringr::str_trim(.x) %>%
                DO.utils::collapse_to_string(unique = TRUE, na.rm = TRUE)
        )
    ) %>%
    dplyr::filter(!is.na(term))

dplyr::count(def_inherit, term) %>%
    dplyr::arrange(term)
```

That captured the autosomal phrases better except for the expansion of 'gene'-derived terms. I think the word gene itself is used widely and not relevant to this examination. Allowing derivatives generally also added irrelevant terms, so 'gene' and its derivatives should probably be limited further and only included when following an autosomal phrase.

Also, it seems that X/Y-linked should be added the variable set of autosomal words to capture broader phrases. I'll move it there and retain the 'link(ed|age)' as its own search to capture other 'link' terms, requiring that no letters come before to avoid overgeneralizing.

```{r}
def_inherit <- def %>%
    dplyr::select(id:parent_label) %>%
    dplyr::filter(!obs) %>%
    dplyr::mutate(
        term = stringr::str_extract_all(
            def,
            DO.utils::collapse_to_string(
                "(",
                "(\\b(autosom|recess|domi|inher|[XY].?link(ed|age)?)[a-z]*\\b ?(gene[a-z]*)?)+|",
                "[^\\-]\\blink(ed|age)?\\b|",
                "(inter|mono|di|poly)genic\\b|", # many "genic" words --> limit
                "de novo\\b",
                ")+", # keep adjacent matching terms together
                delim = ""
            )
        ),
        term = purrr::map_chr(
            term,
            ~ stringr::str_trim(.x) %>%
                DO.utils::collapse_to_string(unique = TRUE, na.rm = TRUE)
        )
    ) %>%
    dplyr::filter(!is.na(term))

dplyr::count(def_inherit, term) %>%
    dplyr::arrange(term)
```

Need to remove standalone 'linked' that's used too broadly and limit 'recess' to avoid 'recession'.

```{r}
def_inherit <- def %>%
    dplyr::select(id:parent_label) %>%
    dplyr::filter(!obs) %>%
    dplyr::mutate(
        term = stringr::str_extract_all(
            def,
            DO.utils::collapse_to_string(
                "(",
                "(\\b(autosom|recessiv|(semi-)?domi|inher|[XY].?link(ed|age)?)[a-z]*\\b ?(gene[a-z]*)?)+|",
                "[^\\-]\\blinkage\\b|",
                "(inter|mono|di|poly)genic\\b|", # many "genic" words --> limit
                "de novo\\b",
                ")+", # keep adjacent matching terms together
                delim = ""
            )
        ),
        term = purrr::map_chr(
            term,
            ~ stringr::str_trim(.x) %>%
                DO.utils::collapse_to_string(unique = TRUE, na.rm = TRUE)
        )
    ) %>%
    dplyr::filter(!is.na(term))

dplyr::count(def_inherit, term) %>%
    dplyr::arrange(term)
```

That should do it.

Now to see the broader phrasing in which these inheritance terms are used. I'm going to exclude as much as I can those inheritance phrases that are at the beginning of the definition because they are part of the parent disease's label, since these will not contribute to the understand of inheritance patterns in definitions.

```{r}
def_inherit <- def %>%
    dplyr::select(id:parent_label) %>%
    DO.utils::collapse_col(parent_label) %>%
    dplyr::filter(!obs) %>%
    dplyr::mutate(
        term = stringr::str_extract_all(
            def,
            DO.utils::collapse_to_string(
                "(",
                "(\\b(autosom|recessiv|(semi-)?domi|inher|[XY].?link(ed|age)?)[a-z]*\\b ?(gene[a-z]*)?)+|",
                "[^\\-]\\blinkage\\b|",
                "(inter|mono|di|poly)genic\\b|", # many "genic" words --> limit
                "de novo\\b",
                ")+", # keep adjacent matching terms together
                delim = ""
            )
        ),
        term = purrr::map(
            term,
            ~ stringr::str_trim(.x) %>%
                unique()
        ),
        term_n = purrr::map_int(term, length)
    ) %>%
    dplyr::filter(term_n > 0) %>%
    tidyr::unnest(term) %>%
    dplyr::mutate(
        phrase = purrr::map2(
            def,
            term,
            ~ tibble::tibble(
                before = stringr::str_extract_all(
                    .x,
                    paste0("([^ ]+[ [:punct:]]*){0,3}", .y)
                ),
                after = stringr::str_extract_all(
                    .x,
                    paste0(.y, "([ [:punct:]]*[^ ]+){0,3}")
                )
            )
        )
    ) %>%
    tidyr::unnest(phrase) %>%
    tidyr::unnest(c(before, after)) %>%
    # remove line where inheritance "term" is near beginning
    dplyr::filter(
        purrr::map2_lgl(
            def,
            before,
            ~ !stringr::str_detect(.x, paste0("^", stringr::str_escape(.y)))
        )
    )
```

The breakdown of text before each inheritance "term" is:

```{r}
def_inherit %>%
    dplyr::count(term, before, sort = TRUE)
```

Hmmm... looks like a lot of "has_material_basis_in" and "characterized by" but the exact counts of those are split due to other text variations. Focusing on those two "terms", the counts become:

```{r}
def_inherit <- def_inherit %>%
    dplyr::mutate(b_common = stringr::str_extract(before, "has_material_basis_in|characterized by"))

def_inherit %>%
    dplyr::count(term, b_common, sort = TRUE) %>%
    dplyr::group_by(b_common) %>%
    dplyr::summarize(
        term = DO.utils::unique_to_string(term, delim = "|", sort = TRUE),
        n = sum(n)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(dplyr::desc(n)) %>%
    add_percent(.col = n)
```

More than half come after "has_material_basis_in" but a sizable amount also follow "characterized by".

What about the text **after** the inheritance phrase?

The breakdown of text after each inheritance "term" is: 
```{r}
def_inherit %>%
    dplyr::count(term, after, sort = TRUE)
```

Looking at this it appears most common to include inheritance after has_material_basis_in but prior to description of the mutation type (homozygous/heterozygous/etc.).

We can assign patterns to different people by organizing by assigned range(s) of IDs (Lynn: 50000,50999 & 80000,85999; etc.).

```{r}
def_inherit <- def_inherit %>%
    dplyr::mutate(
        num_id = as.numeric(stringr::str_remove(id, ".+:")),
        creator = dplyr::case_when(
            num_id < 50000 ~ "pre-2015",
            dplyr::between(num_id, 50000, 50999) | dplyr::between(num_id, 80000, 85999) ~ "Lynn",
            num_id >= 110000 ~ "MODs",
            TRUE ~ "others"
        )
    )

dplyr::count(def_inherit, creator)
```

And then look at trends in has_material_basis vs "characterized by" by author or group:

```{r}
def_inherit <- def_inherit %>%
    dplyr::group_by(creator) %>%
    dplyr::mutate(pseudotime = dplyr::row_number(num_id))

ggplot(def_inherit) +
    geom_freqpoly(aes(x = pseudotime, color = b_common), binwidth = 10) +
    facet_wrap(~ creator, scales = "free_x")
```

Hmmm... it seems pre-2015 additions and those made by Lynn are generally preferred to be made after 'has_material_basis_in' while the MODs and others are variable over time (possibly curator-linked).

Lynn's most 5 recent additions by inheritance term include the following definitions:

```{r}
def_inherit %>%
    dplyr::filter(creator == "Lynn") %>%
    dplyr::mutate(
        group_term = dplyr::case_when(
            stringr::str_detect(term, "autosom|dom|rec") ~ "autosomal",
            stringr::str_detect(term, "[XY]-") ~ "sex-linked",
            stringr::str_detect(term, "inher") ~ "inheritance",
            TRUE ~ term
        )
    ) %>%
    dplyr::group_by(group_term) %>%
    dplyr::slice_max(pseudotime, n = 5) %>%
    dplyr::arrange(group_term, pseudotime) %>%
    dplyr::select(id, group_term, def) %>%
    kbl() %>%
    kable_paper() %>%
    column_spec(3, width = "30em")
```


### Genetic Phrasing

After exploring `has material basis in` statements, it's clear that most have inheritance, specific genes and chromosomal location listed. There are some diseases that don't have clear genes but most will have genetic (i.e. chromosomal) information.

**What patterns are there for definitions with chromosomal locations?**

_EXCLUDING OBSOLETE_

```{r}
chrom <- def %>%
    dplyr::filter(
        !obs,
        stringr::str_detect(def, "chromos")
    ) %>%
    dplyr::select(id, label, def) %>%
    dplyr::distinct() %>%
    tidytext::unnest_tokens(
        output = "word",
        input = def,
        token = "words",
        drop = FALSE
    ) %>%
    dplyr::group_by(id) %>%
    dplyr::mutate(pos = dplyr::row_number()) %>%
    dplyr::ungroup() %>%
    dplyr::anti_join(tidytext::stop_words, by = "word")
    
```

```{r}
# want to find the most common words --> small IDF
chrom_anal <- chrom %>%
    dplyr::count(id, def, word, sort = TRUE) %>%
    tidytext::bind_tf_idf(term = word, document = id, n = n) %>%
    dplyr::group_by(word, idf) %>%
    dplyr::summarize(
        id_n = dplyr::n_distinct(id),
        id_pct = round(id_n / dplyr::n_distinct(chrom$id) * 100, 1)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(idf)

chrom_anal
```

The values other than 'chromosome' include 2 that are typos and need to be fixed with the remainder being expected (and fewer in number than I'd anticipated).

```{r}
dplyr::filter(chrom_anal, str_detect(word, "chromos"), word != "chromosome")
```

'gene' is right up at the top along with other expected inheritance words. One interest I have is in understanding what words are used when 'gene' is not included.

```{r}
no_gene <- chrom %>%
    dplyr::group_by(id) %>%
    dplyr::filter(all(word != "gene")) %>%
    dplyr::ungroup() %>%
    dplyr::count(id, def, word, sort = TRUE) %>%
    tidytext::bind_tf_idf(term = word, document = id, n = n)

no_gene_idf <- no_gene %>%
    dplyr::group_by(word, idf) %>%
    dplyr::summarize(
        id_n = dplyr::n_distinct(id),
        id_pct = round(id_n / dplyr::n_distinct(no_gene$id) * 100, 1)
    ) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(idf)

no_gene_idf
```

'region' > 'mutation' > 'variation' seem to be the most common genetic mutation/location words used when 'gene' is not. Other less frequent (< 10%) possibilities include 'deletion' > 'locus' > 'duplication' ~ 'genes' ~ 'variable' > 'mb' (assuming megabase) ~ 'mapped' ~ 'linkage' ~ 'snps' (i.e. SNPs)

With regard to 'variation' vs 'variant', etc. it appears that DO has a clear and definite preference for variation, not using 'variant' at all.

```{r}
dplyr::filter(no_gene_idf, stringr::str_detect(word, "^var"))
```

I know from prior exploration that 'gene' is most frequently used in the phrase 'the {SYMBOL} gene'.

**What about the phrases for 'region', 'mutation' and 'variation'?**

```{r}
no_gene_phrase <- chrom %>%
    dplyr::filter(word %in% c('region', 'mutation', 'variation')) %>%
    dplyr::mutate(
        phrase = purrr::map2(
            def,
            word, 
            ~ stringr::str_extract_all(
                .x,
                paste0("(?:\\w+ ){0,2}", .y, "(?: \\w+){0,2}")
            )
        )
    ) %>%
    tidyr::unnest(phrase) %>%
    tidyr::unnest(phrase) %>%
    dplyr::select(id, no_gene = word, phrase) %>%
    dplyr::distinct() %>%
    tidytext::unnest_tokens(
        output = "word",
        input = phrase,
        token = "words",
        to_lower = FALSE,
        drop = FALSE
    ) %>%
    dplyr::group_by(no_gene, id, phrase) %>%
    dplyr::mutate(pos = dplyr::row_number()) %>%
    dplyr::ungroup() %>%
    dplyr::filter(pos != 3)

ng_phrase_split <- no_gene_phrase %>%
    tidyr::nest(.by = no_gene) %>%
    tidyr::pivot_wider(names_from = no_gene, values_from = data) %>%
    unlist(recursive = FALSE)

ng_phrase_n <- ng_phrase_split %>%
    purrr::map(
        ~ dplyr::group_by(.x, pos, word) %>%
            dplyr::summarize(
                id_n = dplyr::n_distinct(id),
                id_pct = round(id_n / dplyr::n_distinct(.x$id) * 100, 1),
                .groups = "drop"
            ) %>%
            dplyr::arrange(pos, dplyr::desc(id_n))
    )
```


The most common words at each position surrounding one of these 3 terms can be seen below.

```{r}
ng_phrase_summary <- ng_phrase_n %>%
    purrr::map(
        ~ dplyr::group_by(.x, pos) %>%
            dplyr::mutate(
                max = max(id_pct),
                relevant = cumsum(id_pct) < 80,
                order = dplyr::row_number(-id_pct),
                sig_vs_prior = dplyr::if_else(
                    id_pct >= dplyr::lag(id_pct / 2, default = NA),
                    ">",
                    ">>"
                )
            ) %>%
            dplyr::ungroup() %>%
            dplyr::filter(relevant & order <= 5 | id_pct == max) %>%
            dplyr::select(-relevant)
    )

ng_phrase_summary %>%
    purrr::map(~ dplyr::select(.x, pos:id_pct))
```


Simplifying these back into phrases makes the patterns more apparent.

```{r}
purrr::map2(
    ng_phrase_summary,
    names(ng_phrase_summary),
    ~ dplyr::group_by(.x, pos) %>%
        dplyr::summarize(
            pos_var = DO.utils::sandwich_text(
                stringr::str_trim(
                    paste(
                        dplyr::if_else(!is.na(sig_vs_prior), sig_vs_prior, ""),
                        word,
                        collapse = " "
                    )
                ),
                c("(", ")")
            )
        ) %>%
        { DO.utils::collapse_to_string(
            dplyr::filter(., pos < 3)$pos_var,
            .y,
            dplyr::filter(., pos > 3)$pos_var,
            delim = " "
        ) }
) %>%
    unlist() %>%
    unname()
```


#### Variation, Gene Unknown

When a disease is linked to a specific region on a chromosome and no gene has been identified what is the appropriate pattern to use?

```{r}
hmbi_region <- hmbi %>%
    dplyr::filter(
        stringr::str_detect(def, "region|linkage"),
        # ignore gene-based hmbi statements
        !stringr::str_detect(hmbi, stringr::coll("GENE_SYM")),
        !stringr::str_detect(def, stringr::coll("gene")),
        # ignore deletions and duplications, which are a special case
        !stringr::str_detect(label, "deletion|duplication")
    ) %>%
    dplyr::mutate(
        # ignore chromosome and variant symbols & drop CHROM_SYM
        hmbi = stringr::str_replace_all(
            hmbi,
            "[YX0-9][pqter0-9_.-]+[^ ]*|CHROM_SYM[^ ]*",
            "..."
        )
    )

region_patterns <- dplyr::count(hmbi_region, hmbi, sort = TRUE) %>%
    dplyr::mutate(pct = round(n / sum(n) * 100, 2))
region_patterns
```

Of the `r sum(region_patterns$n)` definitions that fit this pattern in DO, the largest group (`r region_patterns$pct[1]`%) have the pattern `r region_patterns$hmbi[1]`). The next largest group appears to be missing the word "chromosome" before region. It seems most of the patterns could be condensed into this general pattern:

`(inheritance)? (variation|mutation) in (the|a) (chromosom(e|al) region|region|region on chromosome)`

I may standardize these somewhat. If I do that, I'd replace "region" and "chromsomal region" with the more frequent "chromosome region" and replace "a" with the more common "the". I might also replace "mutation" with "variation" but "mutation" is still common in genetic patterns we are creating in the DO, so I'm more hesitant to do that.

Including inheritance in the phrase is fairly common (`r sum(dplyr::filter(region_patterns, stringr::str_detect(hmbi, "inherit|zygous"))$pct)`%) and I think is meaningful. It is much more common to include the phrase as "(hetero|homo|hemi)zygous" than to state the "dominant|recessive" inheritance, which is in a agreement with our other genetic patterns. I'm a bit surprised there are so many "zygous"-based statements since, technically speaking, zygosity is determined based on alleles. I guess it can be inferred from inheritance patterns but not perfectly (e.g. homozygous vs compound heterozygous). Because the "zygous" pattern exists, it seems to suggest it's preferred but it's technical inaccuracy makes me hesitant to use it. Admittedly, the "inheritance"-based pattern has a negative stigma to it. I think that might be because it just doesn't read well in a has_material_basis_in statement.

**No clear answer here**, _but maybe it doesn't matter?_

```{r}
dplyr::filter(region_patterns, stringr::str_detect(hmbi, "inherit|zygous")) %>%
    dplyr::mutate(inheritance = stringr::str_extract(hmbi, "inherit|zygous")) %>%
    dplyr::summarize(.by = inheritance, n = sum(n), pct = sum(pct))
```


Two other patterns I see are one for deletions in a given region (those should've been dropped but weren't and can be ignored here) and one using a different pattern with "linkage" and mentioning SNPs that accounts for only `r sum(dplyr::filter(region_patterns, stringr::str_detect(hmbi, "linkage"))$pct)`%.



## Cellular Proliferation: Phrases or Words

```{r}
cp <- repo$doid$query(
"SELECT ?id
WHERE {
    ?class rdfs:subClassOf* obo:DOID_14566 ;
        oboInOwl:id ?id .
}"
) %>%
    DO.utils::tidy_sparql()

cp_def <- def %>%
    dplyr::filter(id %in% cp$id)
```

1. What is the occurrence of 'characterized by' and 'has_material_basis_in' for cellular proliferation diseases?

```{r}
cp_def %>%
    dplyr::mutate(
        char_by = stringr::str_detect(def, "characterized by"),
        mat_basis = stringr::str_detect(def, "has.material.basis.in")
    ) %>%
    dplyr::count(char_by, mat_basis) %>%
    add_percent(n)
```

These are fairly common but by no means the majority.

2. What is the frequency of cancer-related terminology: arises, develops, located, etc.? 

I'll look at the occurrence of the 3 words following the parent term and then some specific phrases.
```{r}
cp3 <- cp_def %>%
    dplyr::mutate(
        no_parent = purrr::map2_chr(
            def,
            parent_label,
            ~ stringr::str_remove(.x, paste0("An? ?", .y, " *"))
        ),
        ngram = stringr::str_extract(no_parent, "^([[:alnum:]_-]+\\s){1,3}")
    )
```

```{r}
cp_def %>%
    dplyr::mutate(
        word = stringr::str_extract_all(
            def,
            "(derive|arise|develop|located)[^ ]*"
        )
    ) %>%
    tidyr::unnest(word) %>%
    dplyr::count(word, sort = TRUE)
```

As expected, `located_in` is the most common but `derives_from` is also very common. Everything else should probably be avoided.

# Review and Fix?

## First Word

I was surprised that some of the words in the first position of definitions was anything other than "a" or "an". I previously saved a list here to review for later, but these have all been corrected prior to this update.

```{r}
def %>%
    dplyr::select(id, def) %>%
    tidytext::unnest_tokens(
        output = "word",
        input = def,
        token = "words"
    ) %>%
    dplyr::group_by(id) %>%
    dplyr::mutate(pos = dplyr::row_number()) %>%
    dplyr::ungroup() %>%
    dplyr::filter(pos == 1, !word %in% c("a", "an")) %>%
    dplyr::arrange(id) %>%
    dplyr::select(-pos)
```
