---
title: "Comparison: DO, ORDO and GARD "
created: "2023-02-13"
output:
    html_notebook:
        toc: true
        toc_float: true
        df_print: paged
        code_folding: hide
---

# Purpose

To identify missing DO mappings to ORDO and GARD and to identify rare diseases that may be tracked in ORDO or GARD but are not yet in DO.

```{r setup, include = FALSE}
library(here)
library(tidyverse)
library(DO.utils)
library(XML)
library(glue)
```


# Data

The data are sourced as follows:

- **doid.owl** ([v2023-01-30](https://github.com/DiseaseOntology/HumanDiseaseOntology/tree/v2023-01-30) for class information, names/synonyms and xrefs.
- **doid-edit.owl** (commit [bcec8ea8](https://github.com/DiseaseOntology/HumanDiseaseOntology/tree/bcec8ea822f8fd829ae7e4d837281d100b123538)) for definition sources.
- Orphanet's ORDO disease ontology (ORDO, version [4.2](https://www.orphadata.com/ordo/)) for class information and names/synonyms.
- Orphanet's [rare disease alignment](https://www.orphadata.com/alignments/) dataset (	en_product1.json.tar.gz, v1, released 2022-11-28) for xrefs.
- GARD's sitemap (accessed and parsed on 2023-01-18) for identifiers and names.

Going forward, data accessed _might_ be enhanced by accessing Orphanet's SPARQL endpoint (currently in beta testing) and GARD's neo4j knowledge graph (which was published in 2019).

```{r do_data, message = FALSE}
repo_path <- here::here("../Ontologies/HumanDiseaseOntology")
do_path <- file.path(repo_path, "src/ontology/doid.owl")
do_owl <- DO.utils::owl_xml(do_path)

do <- do_owl$query(
    "SELECT ?id ?label ?dep
    WHERE {
        ?class a owl:Class ;
            oboInOwl:id ?id ;
            rdfs:label ?label .
        OPTIONAL { ?class owl:deprecated ?dep . }
    }"
) %>%
    DO.utils::tidy_sparql() %>%
    dplyr::mutate(
        status = dplyr::if_else(is.na(dep), NA_character_, "deprecated")
    ) %>%
    dplyr::select(-dep)

do_xref_all <- do_owl$query(
    "SELECT ?id ?label ?xref
    WHERE {
        ?class a owl:Class ;
            oboInOwl:id ?id ;
            rdfs:label ?label ;
            oboInOwl:hasDbXref ?xref .
    }"
) %>%
    DO.utils::tidy_sparql() %>%
    dplyr::mutate(
        xref = stringr::str_replace_all(
            xref,
            c( "ICD10CM" = "ICD10", "UMLS_CUI" = "UMLS")
        ),
        ns = stringr::str_remove(xref, ":.*")
    )

# drop xrefs ORDO doesn't have
do_xref <- do_xref_all %>%
    dplyr::filter(
        !stringr::str_detect(xref, "EFO|GARD|ICD9|ICDO|KEGG|NCI|SNOMED")
    )

do_syn <- do_owl$query(
    "SELECT ?id ?type ?text
    WHERE {
        {
            ?class a owl:Class ;
                oboInOwl:id ?id ;
                rdfs:label ?text .
            BIND('label' AS ?type)
        }
        UNION
        {
            VALUES ?syn_types {
                oboInOwl:hasExactSynonym
                oboInOwl:hasBroadSynonym
                oboInOwl:hasNarrowSynonym
                oboInOwl:hasRelatedSynonym
            }
            ?class a owl:Class ;
                oboInOwl:id ?id ;
                ?syn_types ?text .
            BIND(
                CONCAT(
                    'synonym_',
                    lcase(
                        STRBEFORE(
                            STRAFTER(str(?syn_types), '#has'),
                            'Synonym'
                        )
                    )
                ) AS ?type
            )
        }
    }"
) %>%
    DO.utils::tidy_sparql()
    

### TOO SLOW!!! Parse doid-edit.owl instead!!! ###
# do_def <- do_owl$query(
#     "SELECT ?id ?label ?def_src
#     WHERE {
#         ?class a owl:Class ;
#             oboInOwl:id ?id ;
#             rdfs:label ?label ;
#             obo:IAO_0000115 ?def .
#         FILTER(CONTAINS(str(?class), 'DOID'))
#         
#         ?blank owl:annotatedSource ?class ;
#             owl:annotatedProperty obo:IAO_0000115 ;
#             owl:annotatedTarget ?def ;
#             oboInOwl:hasDbXref ?def_src .
#     } LIMIT 1"
# ) %>%
#     DO.utils::tidy_sparql()
do_def <- DO.utils:::read_doid_edit(repo_path) %>%
    DO.utils:::extract_doid_url() %>%
    dplyr::filter(stringr::str_detect(url, stringr::coll("orpha.net"))) %>%
    dplyr::mutate(def_src = stringr::str_match(url, "Expert=([0-9]+)")[,2])
```


```{r ordo_owl_data, message = FALSE}
ordo_path <- file.path(odir, "ORDO_en_4.2.owl")

ordo_owl <- DO.utils::owl_xml(ordo_path)
ordo <- ordo_owl$query(
    "PREFIX orpha: <http://www.orpha.net/ORDO/Orphanet_>
    
    SELECT ?id ?label ?branch
    WHERE {
        ?class a owl:Class ;
            rdfs:label ?label .
        OPTIONAL { 
            ?class rdfs:subClassOf+ ?branch_iri .
            ?branch_iri rdfs:subClassOf ?top ;
                rdfs:label ?branch .
            
            VALUES ?top { orpha:C001 orpha:C042 orpha:C046 orpha:C050 }
        }
        BIND(
            CONCAT(
                'ORDO:',
                STRAFTER(str(?class), 'Orphanet_')
            ) AS ?id
        )
    }"
) %>%
    DO.utils::tidy_sparql() %>%
    dplyr::mutate(
        status = stringr::str_extract(branch, "non rare|obsolete|deprecated"),
        class_type = stringr::str_extract(branch, "subtype|group|disorder")
    )


# Works when not limiting to exact mappings (too long otherwise);
#   PARSE .ofn converted file to identify mapping type!!!
ordo_xref_all <- ordo_owl$query(
    "PREFIX efo: <http://www.ebi.ac.uk/efo/>

    SELECT ?id ?label ?xref
    WHERE {
        ?class a owl:Class ;
            oboInOwl:hasDbXref ?xref ;
            rdfs:label ?label .
        BIND(
            CONCAT(
                'ORDO:',
                STRAFTER(str(?class), 'Orphanet_')
            ) AS ?id
        )
    }"
) %>%
    DO.utils::tidy_sparql()

# parse types from ORDO in functional syntax
ordo_ofn <- here::here("../Ontologies/ORDO/ORDO_en_4.2.ofn")
if (!file.exists(ordo_ofn)) {
    system2("robot", glue::glue("--input {ordo_path} --output {ordo_ofn}"))
}
ordo_annotated_xref <- readr::read_lines(ordo_ofn) %>%
    stringr::str_match(
        'Ann[^A]+Ass.*ECO_0000218 "([^"]+).*hasDbXref[^:]*:(Orphanet_[^ ]+) "([^"]+)'
    ) %>%
    tibble::as_tibble(.name_repair = ~ c("full", "type", "id", "xref")) %>%
    dplyr::filter(!is.na(full)) %>%
    dplyr::select(id, xref, type) %>%
    dplyr::mutate(id = stringr::str_replace(id, "Orphanet_", "ORDO:"))

ordo_xref_types <- unique(ordo_xref$type)
      
ordo_xref_all <- ordo_xref %>%
    dplyr::left_join(ordo_annotated_xref, by = c("id", "xref")) %>%
    dplyr::mutate(
        type = stringr::str_remove(type, " .*"),
        xref = stringr::str_replace_all(
            xref,
            c("ICD-10" = "ICD10", "ICD-11" = "ICD11", "MedDRA" = "MEDDRA",
              "MeSH" = "MESH")
        ),
        ns = stringr::str_remove(xref, ":.*")
    )

ordo_xref <- ordo_xref_all %>%
    dplyr::filter(is.na(type) | type == "E")

ordo_syn <- ordo_owl$query(
    "PREFIX efo: <http://www.ebi.ac.uk/efo/>
    
    SELECT ?id ?label ?syn
    WHERE {
        ?class a owl:Class ;
            rdfs:label ?label ;
            efo:alternative_term ?syn .
        BIND(
            CONCAT(
                'ORDO:',
                STRAFTER(str(?class), 'Orphanet_')
            ) AS ?id
        )
    }"
) %>%
    DO.utils::tidy_sparql() %>%
    dplyr::rename(synonym = syn) %>%
    tidyr::pivot_longer(
        cols = c(label, synonym),
        names_to = "type",
        values_to = "text"
    )

ordo_json <- jsonlite::read_json(ordo_xref_path)
ordo_xref <- purrr::map(
    ordo_json$JDBOR[[1]]$DisorderList[[1]]$Disorder,
    tibble::as_tibble
) %>%
    dplyr::bind_rows()

# purrr::map(
#     %>%
#     tidyr::hoist(ExpertLink, "link", )
```


```{r ordo_data, message = FALSE}
odir <- here::here("../Ontologies/ORDO")
ordo_xml_path <- file.path(odir, "en_product1.xml")
ordo_xml <- XML::xmlParse(ordo_xml_path)

parse_xml_list <- function(x, xpath_accessor) {
    if (length(xpath_accessor) < 1) {
        rlang::abort("`xpath_accessor` must be provided.")
    }
    if (length(xpath_accessor) == 1) {
        out <- purrr::map(x, ~ parse_xml_list_element(.x, xpath_accessor))
    } else {
        out <- purrr::map(
            x,
            function(.l) {
                purrr::map(
                    xpath_accessor,
                    ~ parse_xml_list_element(.l, .x)
                ) %>%
                    tibble::as_tibble()
            }
        )
    }
    out
}

parse_xml_list_element <- function(element, xpath_accessor) {
    res <- purrr::map_chr(
        XML::getNodeSet(element, xpath_accessor),
        xmlValue
    )
    dplyr::if_else(length(res) > 0, res, NA_character_) 
}

ordo_df <- tibble::tibble(
    disorder_id = as.character(ordo_xml["string(//Disorder/@id)"]),
    id = paste0(
        "ORDO:",
        XML::xmlValue(ordo_xml["//Disorder/OrphaCode"])
    ),
    label =  XML::xmlValue(ordo_xml["//Disorder/Name[@lang = 'en']"]),
    url = XML::xmlValue(ordo_xml["//Disorder/ExpertLink"]),
    synonym = parse_xml_list(
        ordo_xml["//Disorder/SynonymList"], 
        "Synonym"
    ),
    type = XML::xmlValue(ordo_xml["//Disorder/DisorderType/Name"]),
    group = XML::xmlValue(ordo_xml["//Disorder/DisorderGroup/Name"]),
    flag = parse_xml_list(
        ordo_xml["//Disorder/DisorderFlagList"],
        "DisorderFlag[@id != '475']/Label"
    ),
    xref = parse_xml_list(
        ordo_xml["//Disorder/ExternalReferenceList"],
        c(
          src = "ExternalReference/Source",
          lui = "ExternalReference/Reference",
          type = "ExternalReference/DisorderMappingRelation/Name",
          status = "ExternalReference/DisorderMappingValidationStatus/Name"
        )
    ),
    assocation = parse_xml_list(
        ordo_xml["//Disorder/DisorderDisorderAssociationList"],
        c(
            id = "DisorderDisorderAssociation/TargetDisorder/OrphaCode",
            label = "DisorderDisorderAssociation/TargetDisorder/Name",
            type = "DisorderDisorderAssociationType/Name"
        )
    ),
    def = parse_xml_list(
        ordo_xml["//Disorder/SummaryInformationList"],
        "SummaryInformation/TextSectionList/TextSection[TextSectionType/Name[text() = 'Definition']]/Contents"
    ) %>%
        as.character() %>%
        # remove html formatting
        stringr::str_remove_all("<[^>]+>")
)

ordo_xref <- ordo_df %>%
    dplyr::select(id, label, xref) %>%
    tidyr::unnest_longer(xref) %>%
    tidyr::unnest_wider(xref) %>%
    dplyr::mutate(
        src = stringr::str_remove_all(src, "[^A-Z0-9a-z]") %>%
            stringr::str_to_upper(),
        xref = paste(src, lui, sep = ":"),
        type = stringr::str_remove(type, " .*")
    )
```


```{r ordo_data_json, include = FALSE, message = FALSE}
ordo_json <- jsonlite::fromJSON(ordo_xref_path)
ordo_df_list <- purrr::map_dfr(
    ordo_json$JDBOR[[1]]$DisorderList[[1]]$Disorder,
    tibble::as_tibble
)
ordo_df <- ordo_df_list %>%
    tidyr::hoist(
        ExpertLink, url = "Link") %>%
    tidyr::hoist(Name, label = "label") %>%
    tidyr::hoist(SynonymList, synonyms = list("Synonym", "label"))
    
```

```{r out_for_help, include = FALSE}
do_ordo <- do_xref_all %>%
    dplyr::filter(ns == "ORDO")

do_no_match <- do_xref_all %>%
    dplyr::filter(!id %in% do_ordo$id)

do_no_match %>% 
    dplyr::mutate(
        xref = stringr::str_replace(xref, "SNOMEDCT_US[^:]+", "SNOMEDCT_US")
    ) %>%
    dplyr::select(-ns) %>%
    readr::write_tsv(here::here("data/external/xrefs_in_DO.tsv"))

ordo_no_match <- ordo_xref %>%
    dplyr::filter(!id %in% do_ordo$xref)

ordo_no_match %>%
    dplyr::select(id, label, xref, xref_type = type) %>%
    readr::write_tsv(here::here("data/external/xrefs_in_ORDO.tsv"))

do_ordo_match <- dplyr::inner_join(
    do_no_match,
    dplyr::select(
        ordo_no_match,
        ordo_id = id, ordo_label = label, xref, ordo_type = type
    ),
    by = "xref"
)
    dplyr::filter(xref %in% ordo_no_match$xref)

```


##############################
assign value
E = 1
NTBT/BTNT/ND <= 0.5

```{r gard_data, message = FALSE}
gard_path <- here::here("data/mapping/GARD.tsv")

if (file.exists(gard_path)) {
    gard <- readr::read_tsv(gard_path)
} else {
    gard_xml <- readr::read_file("https://rarediseases.info.nih.gov/sitemap.xml")
    
    gard_info <- stringr::str_match_all(
        gard_xml,
        "https://rarediseases.info.nih.gov/diseases/([0-9]+)/([^< /\"]+)"
    )[[1]]
    
    gard <- tibble::tibble(
        gard_id = paste0("GARD:", gard_info[, 2]),
        label = stringr::str_replace_all(gard_info[, 3], "-", " ")
    ) %>%
        unique()
    readr::write_tsv(gard, gard_path)
}
```


# Approach

Comparison between DO and GARD was accomplished previously in the compare-DO_GARD notebook in this repository. Since the GARD sitemap provides only labels and GARD identifiers, nothing new can be incorporated in this comparison. Instead the focus will be on comparing DO and ORDO in a step-wise manner starting with the strongest information and ending with the weakest.

The comparisons will be as follows:
1. DOID with xref to ORDO --> assumed correct
2. DOID with other xrefs that match ORDO xrefs --> will be ranked based on the number and similarity of xref matches (missing or conflicting xrefs will indicate lower quality)
3. DOID with Orphanet sources for definitions --> few exist but these will be explored as they are likely to be appropriate mappings
3. DOID labels and synonyms will be compared with ORDO labels and synonyms, initially by exact match after standardization followed by approximate string matches.



# 1. DOIDs with ORDO xrefs

```{r do_direct}
do_ordo_xref <- do_xref %>%
    dplyr::filter(ns == "ORDO") %>%
    dplyr::select(-ns) %>%
    dplyr::nest_join(
        dplyr::select(do_xref, -label),
        by = "id",
        name = "do_xref_tbl"
    ) %>%
     dplyr::nest_join(
        dplyr::select(ordo_xref, -label),
        by = c("xref" = "id"),
        name = "ordo_xref_tbl"
    ) %>%
    dplyr::left_join(do)
```

```{r}

```


```{r}
do_no_match <- dplyr::filter(do, !id %in% do_ordo_xref$id)
    
```


# 2. DO-ORDO xref comparison

There are quite a few duplicated xrefs in DO. The most numerous duplications are from ICD10 and MESH but there are decent number from ORDO, UMLS, and MESH as well.

```{r}
do_xref %>%
    dplyr::filter(DO.utils::all_duplicated(xref)) %>%
    dplyr::count(ns, sort = TRUE)
```

Comparing DO to ORDO using xrefs is going to be messy because of this duplication. These really should be eliminated or annotated as broad, narrow or related to clarify how to handle them. ORDO does have these sorts of annotations so it might be possible to pull them from there, but that's outside the scope of work right now. For the time being, ORDO xrefs will be limited to those that are exact.

```{r}
xref_compare <- NULL
```


# Summary

```{r}
rare_xref_counts <- do_xref_all %>%
    dplyr::group_by(id) %>%
    dplyr::summarize(
        rare_xref = dplyr::case_when(
            all(c("ORDO", "GARD") %in% ns) ~ "Both",
            "ORDO" %in% ns ~ "ORDO",
            "GARD" %in% ns ~ "GARD",
            TRUE ~ NA_character_
        )
    ) %>%
    dplyr::filter(!is.na(rare_xref))
```

There are `r format(dplyr::n_distinct(rare_xref_counts$id), big.mark = ",")` diseases with GARD and/or Orphanet xrefs in the latest release of DO with the following breakdown:

```{r}
dplyr::count(rare_xref_counts, rare_xref)
```

The number of GARD and ORDO IDs in the DO:
```{r}
do_xref_all %>%
    dplyr::filter(ns %in% c("GARD", "ORDO")) %>%
    dplyr::group_by(ns) %>%
    dplyr::summarize(n = dplyr::n_distinct(xref))
```

Xref sources in both DO and ORDO
```{r}

```

